[{"categories":["Basic"],"contents":" I\u0026rsquo;m the kind of Spotify user that adds every single song to one single playlist and then complains about not being able to find what he wants to hear. One simple solution would be grouping songs in different playlists by mood, however, this solution is not exciting enough for me\u0026hellip; Instead, I decided to create an app that takes all tracks in a playlist, \u0026ldquo;analyzes\u0026rdquo; and groups them by similarity in an interactive 3D graph, where you can click on a song and automatically play it on Spotify. Ok, maybe that was too much to digest, let\u0026rsquo;s decompose the problem:\nGetting all tracks of a Spotify playlist: Spotify offers an amazing Web API with an endpoint for requesting a list of tracks for a given playlist. Analyze the tracks: I might have lied here\u0026hellip; we are not going to analyze and extract the features of the songs, as Spotify does not give access to the audio data. Instead, Spotify generates a set of song features using their ‚ú®Corporate Secrets‚ú® which are accessible with the Web API. Grouping tracks by similarity: To group similar songs we will follow a dimensionality reduction strategy using the UMAP technique. We will use Plotly to create a 3D interactive graph of the UMAP result that will allow us to select individual songs. Playing selected songs in Spotify: We will use, again, the Spotify Web API to play the song we select in the Plotly graph. ‚ùó Before moving forward: if you are planning to reproduce this project you might need a premium Spotify account to perform some of the API requests. Also, this project assumes you have an intermediate understanding of python, packet managing and other concepts.\nWith that being said, let\u0026rsquo;s dive in!\nSetting up the Spotify Web API requirements The Web API requests require authentication with an OAuth access token. To obtain a token we first need to log in to Spotify for Developers Dashboard:\nOnce we are logged in, we will click on \u0026ldquo;create an app\u0026rdquo; and a form will appear. We will give an awesome name and an awesome description to our app, and we will accept the Developer Terms of Service and Branding Guidelines after fully reading them üëÄ.\nAfter accepting we will be redirected to the app\u0026rsquo;s dashboard. There we will be able to find the Client ID and Client Secret. Note that both are blurred out, you shouldn\u0026rsquo;t share these values anywhere! üôä\nWrite these values in a json file named credentials.json. If you are using git with your code and uploading the repository anywhere (GitHub, for example) add the json file to the .gitignore!\n{ \u0026#34;CLIENT_ID\u0026#34;: \u0026#34;123456789abcdefghijklmnopqrstuvw\u0026#34;, \u0026#34;CLIENT_SECRET\u0026#34;: \u0026#34;123456789abcdefghijklmnopqrstuvw\u0026#34; } Click the \u0026ldquo;EDIT SETTINGS\u0026rdquo; button in the dashboard and add the following redirect URI: https://www.google.com/. This will be used during the authentication process.\nWith this done, we finished setting up the requirements for the Web API.\nAuthenticating First of all, we will load the credentials we stored before:\nimport json with open(\u0026#39;credentials.json\u0026#39;, \u0026#39;r\u0026#39;) as f: credentials = json.load(f) CLIENT_ID = credentials[\u0026#39;CLIENT_ID\u0026#39;] CLIENT_SECRET = credentials[\u0026#39;CLIENT_SECRET\u0026#39;] We will use spotipy, a library that makes interacting with the API simpler. We define a Spotify object as follows:\nimport spotipy as spt SCOPE = \u0026#39;user-modify-playback-state user-library-read user-read-email user-read-private user-top-read user-modify-playback-state user-read-playback-state\u0026#39; REDIRECT_URI = \u0026#39;https://www.google.com/\u0026#39; auth = spt.SpotifyOAuth( client_id=CLIENT_ID, client_secret=CLIENT_SECRET, redirect_uri=REDIRECT_URI, scope=SCOPE, open_browser=True, cache_path=\u0026#39;.cache\u0026#39; ) spotify = spt.Spotify(oauth_manager=auth) The first time you perform a request using the spotify you will be requested to authenticate and a token will be generated. This token will be saved in the file specified in cache_path (in our case, in .cache). Again, if you are using git with your code and uploading the repository anywhere (GitHub, for example) add the cache file to the .gitignore! This authentication will happen only once, as spotipy takes care of refreshing the token when necessary.\nThe authentication process is simple: a web browser will be opened and we will copy the URL where we are redirected and paste it in an input box. Depending on your system, IDE or default browser\u0026hellip; this process can fail. In my case, running the code from a .ipynb file in VS Code fails. To solve it, I run the code from a .py once.\nLet\u0026rsquo;s trigger the authentication process by performing a request:\nspotify.track(\u0026#39;4cOdK2wGLETKBW3PvgPWqT\u0026#39;) Done! Now you won\u0026rsquo;t have to worry about authentication ever again!\nObtaining data First of all, we need to choose a playlist and get its URI. To do so, go to Spotify and choose a playlist, click on the \u0026ldquo;three dots\u0026rdquo; \u0026gt; Share \u0026gt; Copy Spotify URI. You might need to press the CTRL key for this option to appear.\nSave the URI in a variable as follows:\nPLAYLIST_ID = \u0026#39;7fE2CHD6t7eeHLD2ar8zSL\u0026#39; We will use my persona Hip Hop playlist, which contains a huge variety of sub-styles from the old and new schools in the United States, Latin America and Spain. The playlist has a total 2517 tracks (at the moment of creating this blog post), so it should offer a nice amount of data points to work with.\nThen we will construct a pandas DataFrame with the audio features and basic information of all tracks in the playlist:\nimport pandas as pd from tqdm import tqdm d = spotify.playlist_items(playlist_id=PLAYLIST_ID, limit=50) data = [] n = math.ceil(d[\u0026#39;total\u0026#39;] / 50) for i in range(1, n + 1): for item in tqdm(d[\u0026#39;items\u0026#39;], postfix=f\u0026#39;Request {i} of {n}\u0026#39;): track = item[\u0026#39;track\u0026#39;] f = spotify.audio_features(tracks=track[\u0026#39;id\u0026#39;])[0] if f == None: continue features = { \u0026#39;danceability\u0026#39;: f[\u0026#39;danceability\u0026#39;], \u0026#39;energy\u0026#39;: f[\u0026#39;energy\u0026#39;], \u0026#39;key\u0026#39;: f[\u0026#39;key\u0026#39;], \u0026#39;loudness\u0026#39;: f[\u0026#39;loudness\u0026#39;], \u0026#39;mode\u0026#39;: f[\u0026#39;mode\u0026#39;], \u0026#39;speechiness\u0026#39;: f[\u0026#39;speechiness\u0026#39;], \u0026#39;acousticness\u0026#39;: f[\u0026#39;acousticness\u0026#39;], \u0026#39;instrumentalness\u0026#39;: f[\u0026#39;instrumentalness\u0026#39;], \u0026#39;liveness\u0026#39;: f[\u0026#39;liveness\u0026#39;], \u0026#39;valence\u0026#39;: f[\u0026#39;valence\u0026#39;], \u0026#39;tempo\u0026#39;: f[\u0026#39;tempo\u0026#39;], \u0026#39;track_name\u0026#39;: track[\u0026#39;name\u0026#39;], \u0026#39;artists_names\u0026#39;: [], \u0026#39;album_name\u0026#39;: track[\u0026#39;album\u0026#39;][\u0026#39;name\u0026#39;], \u0026#39;release_date\u0026#39;: track[\u0026#39;album\u0026#39;][\u0026#39;release_date\u0026#39;], \u0026#39;track_id\u0026#39;: track[\u0026#39;id\u0026#39;], } for a in track[\u0026#39;artists\u0026#39;]: features[\u0026#39;artists_names\u0026#39;].append(a[\u0026#39;name\u0026#39;]) data.append(features) d = spotify.playlist_items(playlist_id=PLAYLIST_ID, limit=50, offset=50*i) df = pd.DataFrame(data) Woah! That\u0026rsquo;s a fair chunk to digest, let\u0026rsquo;s explain it a little bit. The Spotify API request for retrieving tracks from a playlist has a maximum of 50 tracks. However, it has an offset parameter that allows us to change which is the first song requested. Using this little trick, we can calculate how many requests we need to download the full playlist! Note that I\u0026rsquo;m using tqdm for printing some progress bars.\nFor each track, we save the following audio features:\nDanceability: A confidence measure from 0.0 to 1.0 of whether the track is acoustic. 1.0 represents high confidence the track is acoustic. Energy: A measure from 0.0 to 1.0 that represents a perceptual measure of intensity and activity. Typically, energetic tracks feel fast, loud, and noisy. For example, death metal has high energy, while a Bach prelude scores low on the scale. Perceptual features contributing to this attribute include dynamic range, perceived loudness, timbre, onset rate, and general entropy. Key: The key the track is in. Integers map to pitches using standard Pitch Class notation. E.g. 0 = C, 1 = C‚ôØ/D‚ô≠, 2 = D, and so on. If no key was detected, the value is -1. Loudness: The overall loudness of a track in decibels (dB). Loudness values are averaged across the entire track and are useful for comparing the relative loudness of tracks. Loudness is the quality of a sound that is the primary psychological correlate of physical strength (amplitude). Values typically range between -60 and 0 db. Mode: Indicates the modality (major or minor) of a track, the type of scale from which its melodic content is derived. Major is represented by 1 and minor is 0. Speechiness: Detects the presence of spoken words in a track. The more exclusively speech-like the recording (e.g. talk show, audio book, poetry), the closer to 1.0 the attribute value. Values above 0.66 describe tracks that are probably made entirely of spoken words. Values between 0.33 and 0.66 describe tracks that may contain both music and speech, either in sections or layered, including such cases as rap music. Values below 0.33 most likely represent music and other non-speech-like tracks. Acousticness: A confidence measure from 0.0 to 1.0 of whether the track is acoustic. 1.0 represents high confidence the track is acoustic. Instrumentalness: Predicts whether a track contains no vocals. \u0026ldquo;Ooh\u0026rdquo; and \u0026ldquo;aah\u0026rdquo; sounds are treated as instrumental in this context. Rap or spoken word tracks are clearly \u0026ldquo;vocal\u0026rdquo;. The closer the instrumentalness value is to 1.0, the greater likelihood the track contains no vocal content. Values above 0.5 are intended to represent instrumental tracks, but confidence is higher as the value approaches 1.0. Liveness: Detects the presence of an audience in the recording. Higher liveness values represent an increased probability that the track was performed live. A value above 0.8 provides a strong likelihood that the track is live. Valence: A measure from 0.0 to 1.0 describing the musical positiveness conveyed by a track. Tracks with high valence sound more positive (e.g. happy, cheerful, euphoric), while tracks with low valence sound more negative (e.g. sad, depressed, angry). Tempo: The overall estimated tempo of a track in beats per minute (BPM). In musical terminology, the tempo is the speed or pace of a given piece and derives directly from the average beat duration. Note that I copied these descriptions from the API reference. We also include other information: the track name, a list of artists\u0026rsquo; names, the album name, the release date and the track URI (the latter is a surprise tool that will help us later).\nThe downloading of the tracks can take a while (especially for large playlists), so it is interesting to save the data into a csv:\ndf.to_csv(\u0026#39;data.csv\u0026#39;, index=False) The next time we what to run the code, it will be enough to load the csv:\ndf = pd.read_csv(\u0026#39;data.csv\u0026#39;) Exploratory Data Analysis Ok, we already have the data, can we jump straight into grouping them with UMAP? NO! Let\u0026rsquo;s have some fun with some exploratory data analysis first, we might get some interesting insights. I will use Plotly for plotting, as it allows me to generate interactive plots that can be inserted into this blog, but feel free to use your favorite library!\nLet\u0026rsquo;s visualize the distribution of the different features. Some features are bounded between 0 and 1, while others are unbounded. For this reason, I will separate the into different subplots.\nimport plotly.graph_objects as go from plotly.subplots import make_subplots features, values, track_name = [], [], [] for c in list(df.loc[:,:\u0026#39;tempo\u0026#39;].columns): features.extend([c for _ in range(len(df))]) values.extend(list(df[c])) track_name.extend(list(df[\u0026#39;track_name\u0026#39;])) outlier_df = pd.DataFrame(list(zip(features, values, track_name)), columns=[\u0026#39;features\u0026#39;, \u0026#39;values\u0026#39;, \u0026#39;track_name\u0026#39;]) outlier_df_0 = outlier_df.loc[ (outlier_df[\u0026#39;features\u0026#39;] != \u0026#39;tempo\u0026#39;) \u0026amp; (outlier_df[\u0026#39;features\u0026#39;] != \u0026#39;loudness\u0026#39;) \u0026amp; (outlier_df[\u0026#39;features\u0026#39;] != \u0026#39;key\u0026#39;) ] outlier_df_1 = outlier_df.loc[(outlier_df[\u0026#39;features\u0026#39;] == \u0026#39;tempo\u0026#39;)] outlier_df_2 = outlier_df.loc[(outlier_df[\u0026#39;features\u0026#39;] == \u0026#39;loudness\u0026#39;)] outlier_df_3 = outlier_df.loc[(outlier_df[\u0026#39;features\u0026#39;] == \u0026#39;key\u0026#39;)] fig = make_subplots(rows=1, cols=4, column_widths=[0.7, 0.1, 0.1, 0.1]) fig.add_trace( go.Box(x=outlier_df_0[\u0026#39;features\u0026#39;], y=outlier_df_0[\u0026#39;values\u0026#39;], hovertext = list(outlier_df_0[\u0026#39;track_name\u0026#39;]), boxpoints=\u0026#39;all\u0026#39;), row=1, col=1 ) fig.add_trace( go.Box(x=outlier_df_1[\u0026#39;features\u0026#39;], y=outlier_df_1[\u0026#39;values\u0026#39;], hovertext = list(outlier_df_0[\u0026#39;track_name\u0026#39;]), boxpoints=\u0026#39;all\u0026#39;), row=1, col=2 ) fig.add_trace( go.Box(x=outlier_df_2[\u0026#39;features\u0026#39;], y=outlier_df_2[\u0026#39;values\u0026#39;], hovertext = list(outlier_df_0[\u0026#39;track_name\u0026#39;]), boxpoints=\u0026#39;all\u0026#39;), row=1, col=3 ) fig.add_trace( go.Box(x=outlier_df_3[\u0026#39;features\u0026#39;], y=outlier_df_3[\u0026#39;values\u0026#39;], hovertext = list(outlier_df_0[\u0026#39;track_name\u0026#39;]), boxpoints=\u0026#39;all\u0026#39;), row=1, col=4 ) fig.update_layout(height=700, showlegend=False) fig.show() First of all, one thing that pops up is how high the tempo values get: the song with the highest tempo (\u0026ldquo;93 till\u0026rsquo; Infinity\u0026rdquo; by Souls of Mischief) has around 206 BPM! This is an incredibly fast tempo for a Hip Hop song üòï. Let\u0026rsquo;s investigate further using this webpage.\nThe instrumental version of the track has exactly half the BPM (which is, actually, the correct BPM). However, when performing a qualitative analysis (listening to the track) we can hear lots of rhythmic elements which give the sensation of a double-tempo. The conclusion is that, while the tempo metric might not be accurate, it\u0026rsquo;s not perceptually wrong.\nAnother interesting relation to study is how loudness has increased over the years. In music production, the Loudness War explains how the audio level tends to increase over the years to give the consumer a false sensation of \u0026ldquo;better sounding\u0026rdquo;. Let\u0026rsquo;s see if we can observe this in our data!\nyear = [] for i in range(len(df)): y = df[\u0026#39;release_date\u0026#39;][i].split(\u0026#39;-\u0026#39;)[0] if y == \u0026#39;0000\u0026#39;: y = \u0026#39;2000\u0026#39; # Dirty NaN imputing year.append(y) df[\u0026#39;year\u0026#39;] = year year_mean_df = df.groupby(\u0026#39;year\u0026#39;, as_index=False).mean() year_min_df = df.groupby(\u0026#39;year\u0026#39;, as_index=False).min() year_max_df = df.groupby(\u0026#39;year\u0026#39;, as_index=False).max() x = list(year_mean_df[\u0026#39;year\u0026#39;]) x_rev = x[::-1] mean = list(year_mean_df[\u0026#39;loudness\u0026#39;]) upper = list(year_max_df[\u0026#39;loudness\u0026#39;]) lower = list(year_min_df[\u0026#39;loudness\u0026#39;]) lower = lower[::-1] fig = go.Figure() fig.add_trace(go.Scatter( x=x+x_rev, y=upper+lower, fill=\u0026#39;toself\u0026#39;, fillcolor=\u0026#39;rgba(0,100,80,0.2)\u0026#39;, line_color=\u0026#39;rgba(255,255,255,0)\u0026#39;, showlegend=False )) fig.add_trace(go.Scatter( x=x, y=mean, line_color=\u0026#39;rgb(0,100,80)\u0026#39; )) fig.update_traces(mode=\u0026#39;lines\u0026#39;, showlegend=False) fig[\u0026#39;layout\u0026#39;].update(height=800, autosize=True) fig.show() We can observe this tendency in our data too, with a clear increase from 1992 peaking in 2006. After this year, we observe how the loudness tends to fall again. This coincides with the decrease in popularity of the CD in favor of digital formats and streaming services, which make use of standardization techniques that makes pumping up the audio level unnecessary, as explained by this article.\nFinally, let\u0026rsquo;s have a look to the correlation matrix of the variables.\nimport numpy as np import plotly.figure_factory as ff df_corr = df.loc[:,:\u0026#39;tempo\u0026#39;].corr() x = list(df_corr.columns) y = list(df_corr.index) z = np.array(df_corr) fig = ff.create_annotated_heatmap( z, x = x, y = y , annotation_text = np.around(z, decimals=2), hoverinfo=\u0026#39;z\u0026#39;, colorscale=\u0026#39;thermal\u0026#39; ) fig[\u0026#39;layout\u0026#39;].update(height=800, width=800) fig.show() We can see a strong positive correlation between loudness and energy. Other than that, the heatmap does not reveal much more.\nUMAP That is enough analysis for today, let\u0026rsquo;s return to the objective of the post!\nBefore applying the UMAP we should normalize all features to the same range. There are many sophisticated ways of doing so to take into account outliers, but given the nature of our data let\u0026rsquo;s go simple: the minmax_scale of sklearn will do.\nfrom sklearn.preprocessing import minmax_scale scaled = minmax_scale(df.loc[:,:\u0026#39;tempo\u0026#39;]) scaled = pd.DataFrame(scaled, columns=list(df.loc[:,:\u0026#39;tempo\u0026#39;].columns)) df_scaled = df.copy() df_scaled.loc[:,:\u0026#39;tempo\u0026#39;] = scaled Let\u0026rsquo;s give a look to the new data:\nimport plotly.express as px features, values, track_name = [], [], [] for c in list(df_scaled.loc[:,:\u0026#39;tempo\u0026#39;].columns): features.extend([c for _ in range(len(df_scaled))]) values.extend(list(df_scaled[c])) track_name.extend(list(df_scaled[\u0026#39;track_name\u0026#39;])) outlier_df = pd.DataFrame(list(zip(features, values, track_name)), columns=[\u0026#39;features\u0026#39;, \u0026#39;values\u0026#39;, \u0026#39;track_name\u0026#39;]) fig = px.box(outlier_df, x=\u0026#34;features\u0026#34;, y=\u0026#34;values\u0026#34;, points=\u0026#34;all\u0026#34;, hover_data=[\u0026#39;track_name\u0026#39;]) fig.show() This looks a lot better! Don\u0026rsquo;t hesitate to try different techniques, as this could be improved further. Now it\u0026rsquo;s time to apply the UMAP to the data:\nfrom umap import UMAP umap = UMAP(n_components=3) proj_3d = umap.fit_transform(df_scaled.loc[:,:\u0026#39;tempo\u0026#39;]) proj_3d_df = pd.DataFrame(proj_3d, columns=[\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;]) proj_3d_df[\u0026#39;track_name\u0026#39;] = df[\u0026#39;track_name\u0026#39;] And now, the moment of truth\u0026hellip; Let\u0026rsquo;s plot our UMAP:\nf = go.FigureWidget() f.add_trace(go.Scatter3d( x=proj_3d[:,0], y=proj_3d[:,1], z=proj_3d[:,2], mode = \u0026#39;markers\u0026#39;, hovertext = list(proj_3d_df[\u0026#39;track_name\u0026#39;]) )) f[\u0026#39;layout\u0026#39;].update(width=800, height=800, autosize=False) f.for_each_trace(lambda t: t.update({\u0026#34;marker\u0026#34;:{\u0026#34;size\u0026#34;:1}})) def click_callback(trace, points, selector): track = data[points.point_inds[0]] spotify.add_to_queue(uri=track[\u0026#39;track_id\u0026#39;]) spotify.next_track() print(f\u0026#39;Song: {track[\u0026#34;track_name\u0026#34;]} | URI: {track[\u0026#34;track_id\u0026#34;]}\u0026#39;) f.data[0].on_click(click_callback) f That is fantastic! üòç Did you notice that click_callback function? Here is where our surprise tool comes handy. We added a click event on each data point that sends a request to spotify to change the currently playing track to the one selected. Keep in mind that you need to have spotify opened and playing for it to work and that this functionality won\u0026rsquo;t work with this blog\u0026rsquo;s plot! Are you starting to see the potential of this idea? Then wait, because we are going to make another step forward!\nClustering Before going ahead, it\u0026rsquo;s time for a quick disclaimer: the validity of UMAP as a preprocessing step for clustering is something that it is currently being discussed by the scientific community. Some papers (1) claim to improve substantially the performance of multiple clustering algorithms by applying UMAP first. However, UMAP does not preserve distance nor density between data points, which can affect distance and density-based clustering algorithms (2). Having this said, let\u0026rsquo;s move on!\nWe will use HDBSCAN, which has proven to work very well with UMAP:\nimport hdbscan labels = hdbscan.HDBSCAN( min_samples=5, min_cluster_size=20, gen_min_span_tree=True, cluster_selection_method=\u0026#39;leaf\u0026#39; ).fit_predict(proj_3d) if labels.min() == -1: labels += 1 proj_3d_df[\u0026#39;labels\u0026#39;] = list(labels) df[\u0026#39;labels\u0026#39;] = list(labels) Let\u0026rsquo;s plot the results:\nimport seaborn as sns color_palette = sns.color_palette(\u0026#39;tab20\u0026#39;, n_colors=len(np.unique(labels))) color_palette[0] = (0.5, 0.5, 0.5) colors = [f\u0026#39;rgb({c[0]*255},{c[1]*255},{c[2]*255})\u0026#39; for c in color_palette] fig=go.FigureWidget() for i in list(np.unique(labels)): dfp = proj_3d_df[proj_3d_df[\u0026#39;labels\u0026#39;]==i] fig.add_traces(go.Scatter3d( x=dfp[\u0026#39;0\u0026#39;], y=dfp[\u0026#39;1\u0026#39;], z=dfp[\u0026#39;2\u0026#39;], mode = \u0026#39;markers\u0026#39;, hovertext = list(dfp[\u0026#39;track_name\u0026#39;]), name=f\u0026#39;{i}\u0026#39;, marker_color=colors[i] )) fig[\u0026#39;layout\u0026#39;].update(width=800, height=800, autosize=False) fig.for_each_trace(lambda t: t.update({\u0026#34;marker\u0026#34;:{\u0026#34;size\u0026#34;:2}})) def click_callback(trace, points, selector): if len(points.point_inds) \u0026gt; 0: dfp = df[df[\u0026#39;labels\u0026#39;] == points.trace_index] track = dfp.iloc[points.point_inds[0]] spotify.add_to_queue(uri=track[\u0026#34;track_id\u0026#34;]) spotify.next_track() print(f\u0026#39;Song: {track[\u0026#34;track_name\u0026#34;]} | URI: {track[\u0026#34;track_id\u0026#34;]}\u0026#39;) for t in fig.data: t.on_click(click_callback) fig Not that bad! There are a lot of tracks that have been clustered as \u0026ldquo;outliers\u0026rdquo;. These are represented by the label \u0026ldquo;0\u0026rdquo;, and can be hidden by clicking the corresponding label in the legend.\nTo Do Thank you for reading this post! I think this is an idea with a lot of potential that needs improving and polishing. I might try in the future and write a new post about this, but in the meantime, these are some things you can try out!\nTry with your own playlists! The playlist we used only contains Hip Hop, so why not try a more variate one? Fill a playlist with Debussy and Skrillex and try again! My standardization process was extremely basic, try more complex and specialized techniques, and the results might improve. UMAP has multiple parameters that can be tweaked to improve the results, and I haven\u0026rsquo;t bothered to experiment with them, why not try them out? HDBSCAN also has multiple parameters to play with. I found good results with the ones I\u0026rsquo;ve chosen, but I didn\u0026rsquo;t do exhaustive research. Include new features, or exclude existing features, in the analysis. See you at the next one!\n","date":"June 8, 2020","hero":"/posts/projects/spotify/improving-spotify-with-umap-v1/images/header.jpg","permalink":"https://Jose-Verdu-Diaz.github.io/posts/projects/spotify/improving-spotify-with-umap-v1/","summary":"I\u0026rsquo;m the kind of Spotify user that adds every single song to one single playlist and then complains about not being able to find what he wants to hear. One simple solution would be grouping songs in different playlists by mood, however, this solution is not exciting enough for me\u0026hellip; Instead, I decided to create an app that takes all tracks in a playlist, \u0026ldquo;analyzes\u0026rdquo; and groups them by similarity in an interactive 3D graph, where you can click on a song and automatically play it on Spotify.","tags":["Markdown","Content Organization","Multi-lingual"],"title":"Improving Spotify with UMAP v1"}]